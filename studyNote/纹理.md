 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。

纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。**使用纹理坐标获取纹理颜色叫做采样(Sampling)。**纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。

![tex_coords](tex_coords.png)



### 纹理环绕方式

纹理坐标的范围通常是从(0,0) 到(1,1),那如果我们把纹理坐标设置在范围之外会发生什么呢？答：OpenGL默认的行为是重复这个纹理图像（我们基本忽略浮点纹理坐标的整数部分）；但OpenGL提供了更多的选择：

> GL_REPEAT,  对纹理的默认行为，重复纹理图像
>
> GL_MIRRORE_REPEATE: 和GL_REPEATE一样，每次重复图片是镜像放置的；
>
> GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出部分会重复纹理坐标的边缘，产生边缘拉伸的效果；
>
> GL_CLAMP_TOBORDER 超出部分坐标为用户指定的边缘颜色

当纹理坐标超出默认范围是，每个选项都有不同的视觉效果输出；下图为这些纹理图像的例子：

![texture_wrapping](texture_wrapping.png)

glTexParameter* 函数对单独的一个坐标轴设置（s t（如果是使用3D纹理那么还有一个r）它们和  x,y,z是等价的）：

> glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
>
> glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);

参数的具体说明：
第一个参数指定了绑定纹理目标；我们使用的是2D纹理

第二个参数需要指定我们设置的选项和应用的纹理轴。我们打算配置的是WARP选项，并指定S和T轴。最后一个参数需要我们传递一个环绕方式，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT

<!-- 如果我们选项是GL_CLAMP_TOBORDER，我们还需要指定一个边缘的颜色，这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组最为边缘颜色值-->

>**float** borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f }; 
>
>glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);



### 纹理过滤

​       纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：*GL_NEAREST和GL_LINEAR*。

​		GL_NEARWEST (也叫邻近过滤，Nearest Neighbor Filtering )是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素.

GL_LINK(也叫先行过滤,(BI)linear Filtering)它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终样本颜色的贡献越大。

这两个纹理过滤方式的视觉效果如下图所示：

![texture_filtering](texture_filtering.png)

GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。

当进行放大(magnify)和(minify) 操作的时候可以设置纹理过滤的选项,比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：

> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);   
>
> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);